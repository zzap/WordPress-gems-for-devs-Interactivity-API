{
  "version": 3,
  "sources": ["../../src/proxies/registry.ts"],
  "sourcesContent": ["/**\n * Proxies for each object.\n */\nconst objToProxy = new WeakMap< object, object >();\nconst proxyToObj = new WeakMap< object, object >();\n\n/**\n * Namespaces for each created proxy.\n */\nconst proxyToNs = new WeakMap< object, string >();\n\n/**\n * Object types that can be proxied.\n */\nconst supported = new Set( [ Object, Array ] );\n\n/**\n * Returns a proxy to the passed object with the given handlers, assigning the\n * specified namespace to it. If a proxy for the passed object was created\n * before, that proxy is returned.\n *\n * @param namespace The namespace that will be associated to this proxy.\n * @param obj       The object to proxify.\n * @param handlers  Handlers that the proxy will use.\n *\n * @throws Error if the object cannot be proxified. Use {@link shouldProxy} to\n *         check if a proxy can be created for a specific object.\n *\n * @return The created proxy.\n */\nexport const createProxy = < T extends object >(\n\tnamespace: string,\n\tobj: T,\n\thandlers: ProxyHandler< T >\n): T => {\n\tif ( ! shouldProxy( obj ) ) {\n\t\tthrow Error( 'This object cannot be proxified.' );\n\t}\n\tif ( ! objToProxy.has( obj ) ) {\n\t\tconst proxy = new Proxy( obj, handlers );\n\t\tobjToProxy.set( obj, proxy );\n\t\tproxyToObj.set( proxy, obj );\n\t\tproxyToNs.set( proxy, namespace );\n\t}\n\treturn objToProxy.get( obj ) as T;\n};\n\n/**\n * Returns the proxy for the given object. If there is no associated proxy, the\n * function returns `undefined`.\n *\n * @param obj Object from which to know the proxy.\n * @return Associated proxy or `undefined`.\n */\nexport const getProxyFromObject = < T extends object >(\n\tobj: T\n): T | undefined => objToProxy.get( obj ) as T;\n\n/**\n * Gets the namespace associated with the given proxy.\n *\n * Proxies have a namespace assigned upon creation. See {@link createProxy}.\n *\n * @param proxy Proxy.\n * @return Namespace.\n */\nexport const getNamespaceFromProxy = ( proxy: object ): string =>\n\tproxyToNs.get( proxy )!;\n\n/**\n * Checks if a given object can be proxied.\n *\n * @param candidate Object to know whether it can be proxied.\n * @return True if the passed instance can be proxied.\n */\nexport const shouldProxy = (\n\tcandidate: any\n): candidate is Object | Array< unknown > => {\n\tif ( typeof candidate !== 'object' || candidate === null ) {\n\t\treturn false;\n\t}\n\treturn (\n\t\t! proxyToNs.has( candidate ) && supported.has( candidate.constructor )\n\t);\n};\n\n/**\n * Returns the target object for the passed proxy. If the passed object is not a registered proxy, the\n * function returns `undefined`.\n *\n * @param proxy Proxy from which to know the target.\n * @return The target object or `undefined`.\n */\nexport const getObjectFromProxy = < T extends object >(\n\tproxy: T\n): T | undefined => proxyToObj.get( proxy ) as T;\n"],
  "mappings": ";AAGA,IAAM,aAAa,oBAAI,QAA0B;AACjD,IAAM,aAAa,oBAAI,QAA0B;AAKjD,IAAM,YAAY,oBAAI,QAA0B;AAKhD,IAAM,YAAY,oBAAI,IAAK,CAAE,QAAQ,KAAM,CAAE;AAgBtC,IAAM,cAAc,CAC1B,WACA,KACA,aACO;AACP,MAAK,CAAE,YAAa,GAAI,GAAI;AAC3B,UAAM,MAAO,kCAAmC;AAAA,EACjD;AACA,MAAK,CAAE,WAAW,IAAK,GAAI,GAAI;AAC9B,UAAM,QAAQ,IAAI,MAAO,KAAK,QAAS;AACvC,eAAW,IAAK,KAAK,KAAM;AAC3B,eAAW,IAAK,OAAO,GAAI;AAC3B,cAAU,IAAK,OAAO,SAAU;AAAA,EACjC;AACA,SAAO,WAAW,IAAK,GAAI;AAC5B;AASO,IAAM,qBAAqB,CACjC,QACmB,WAAW,IAAK,GAAI;AAUjC,IAAM,wBAAwB,CAAE,UACtC,UAAU,IAAK,KAAM;AAQf,IAAM,cAAc,CAC1B,cAC4C;AAC5C,MAAK,OAAO,cAAc,YAAY,cAAc,MAAO;AAC1D,WAAO;AAAA,EACR;AACA,SACC,CAAE,UAAU,IAAK,SAAU,KAAK,UAAU,IAAK,UAAU,WAAY;AAEvE;AASO,IAAM,qBAAqB,CACjC,UACmB,WAAW,IAAK,KAAM;",
  "names": []
}
