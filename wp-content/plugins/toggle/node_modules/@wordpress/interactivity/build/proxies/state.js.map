{"version":3,"names":["_signals","require","_registry","_signals2","_namespaces","_utils","wellKnownSymbols","Set","Object","getOwnPropertyNames","Symbol","map","key","filter","value","proxyToProps","WeakMap","hasPropSignal","proxy","has","get","exports","readOnlyProxies","WeakSet","getPropSignal","initial","set","Map","props","ns","getNamespaceFromProxy","prop","PropSignal","setGetter","readOnly","setValue","shouldProxy","proxifyState","objToIterable","peeking","stateHandlers","target","receiver","hasOwnProperty","Reflect","desc","getOwnPropertyDescriptor","result","getComputed","args","setNamespace","call","resetNamespace","defineProperty","getProxyFromObject","isNew","Array","isArray","length","deleteProperty","undefined","ownKeys","signal","_","namespace","obj","options","createProxy","add","peek","deepMergeRecursive","source","override","isPlainObject","hasNewKeys","propSignal","configurable","enumerable","targetValue","deepMerge","batch","getObjectFromProxy"],"sources":["@wordpress/interactivity/src/proxies/state.ts"],"sourcesContent":["/**\n * External dependencies\n */\nimport { batch, signal, type Signal } from '@preact/signals';\n\n/**\n * Internal dependencies\n */\nimport {\n\tcreateProxy,\n\tgetProxyFromObject,\n\tgetNamespaceFromProxy,\n\tshouldProxy,\n\tgetObjectFromProxy,\n} from './registry';\nimport { PropSignal } from './signals';\nimport { setNamespace, resetNamespace } from '../namespaces';\nimport { isPlainObject } from '../utils';\n\n/**\n * Set of built-in symbols.\n */\nconst wellKnownSymbols = new Set(\n\tObject.getOwnPropertyNames( Symbol )\n\t\t.map( ( key ) => Symbol[ key ] )\n\t\t.filter( ( value ) => typeof value === 'symbol' )\n);\n\n/**\n * Relates each proxy with a map of {@link PropSignal} instances, representing\n * the proxy's accessed properties.\n */\nconst proxyToProps: WeakMap<\n\tobject,\n\tMap< string | symbol, PropSignal >\n> = new WeakMap();\n\n/**\n *  Checks whether a {@link PropSignal | `PropSignal`} instance exists for the\n *  given property in the passed proxy.\n *\n * @param proxy Proxy of a state object or array.\n * @param key   The property key.\n * @return `true` when it exists; false otherwise.\n */\nexport const hasPropSignal = ( proxy: object, key: string ) =>\n\tproxyToProps.has( proxy ) && proxyToProps.get( proxy )!.has( key );\n\nconst readOnlyProxies = new WeakSet();\n\n/**\n * Returns the {@link PropSignal | `PropSignal`} instance associated with the\n * specified prop in the passed proxy.\n *\n * The `PropSignal` instance is generated if it doesn't exist yet, using the\n * `initial` parameter to initialize the internal signals.\n *\n * @param proxy   Proxy of a state object or array.\n * @param key     The property key.\n * @param initial Initial data for the `PropSignal` instance.\n * @return The `PropSignal` instance.\n */\nconst getPropSignal = (\n\tproxy: object,\n\tkey: string | number | symbol,\n\tinitial?: PropertyDescriptor\n) => {\n\tif ( ! proxyToProps.has( proxy ) ) {\n\t\tproxyToProps.set( proxy, new Map() );\n\t}\n\tkey = typeof key === 'number' ? `${ key }` : key;\n\tconst props = proxyToProps.get( proxy )!;\n\tif ( ! props.has( key ) ) {\n\t\tconst ns = getNamespaceFromProxy( proxy );\n\t\tconst prop = new PropSignal( proxy );\n\t\tprops.set( key, prop );\n\t\tif ( initial ) {\n\t\t\tconst { get, value } = initial;\n\t\t\tif ( get ) {\n\t\t\t\tprop.setGetter( get );\n\t\t\t} else {\n\t\t\t\tconst readOnly = readOnlyProxies.has( proxy );\n\t\t\t\tprop.setValue(\n\t\t\t\t\tshouldProxy( value )\n\t\t\t\t\t\t? proxifyState( ns, value, { readOnly } )\n\t\t\t\t\t\t: value\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\treturn props.get( key )!;\n};\n\n/**\n * Relates each proxied object (i.e., the original object) with a signal that\n * tracks changes in the number of properties.\n */\nconst objToIterable = new WeakMap< object, Signal< number > >();\n\n/**\n * When this flag is `true`, it avoids any signal subscription, overriding state\n * props' \"reactive\" behavior.\n */\nlet peeking = false;\n\n/**\n * Handlers for reactive objects and arrays in the state.\n */\nconst stateHandlers: ProxyHandler< object > = {\n\tget( target: object, key: string | symbol, receiver: object ): any {\n\t\t/*\n\t\t * The property should not be reactive for the following cases:\n\t\t * 1. While using the `peek` function to read the property.\n\t\t * 2. The property exists but comes from the Object or Array prototypes.\n\t\t * 3. The property key is a known symbol.\n\t\t */\n\t\tif (\n\t\t\tpeeking ||\n\t\t\t( ! target.hasOwnProperty( key ) && key in target ) ||\n\t\t\t( typeof key === 'symbol' && wellKnownSymbols.has( key ) )\n\t\t) {\n\t\t\treturn Reflect.get( target, key, receiver );\n\t\t}\n\n\t\t// At this point, the property should be reactive.\n\t\tconst desc = Object.getOwnPropertyDescriptor( target, key );\n\t\tconst prop = getPropSignal( receiver, key, desc );\n\t\tconst result = prop.getComputed().value;\n\n\t\t/*\n\t\t * Check if the property is a synchronous function. If it is, set the\n\t\t * default namespace. Synchronous functions always run in the proper scope,\n\t\t * which is set by the Directives component.\n\t\t */\n\t\tif ( typeof result === 'function' ) {\n\t\t\tconst ns = getNamespaceFromProxy( receiver );\n\t\t\treturn ( ...args: unknown[] ) => {\n\t\t\t\tsetNamespace( ns );\n\t\t\t\ttry {\n\t\t\t\t\treturn result.call( receiver, ...args );\n\t\t\t\t} finally {\n\t\t\t\t\tresetNamespace();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\treturn result;\n\t},\n\n\tset(\n\t\ttarget: object,\n\t\tkey: string,\n\t\tvalue: unknown,\n\t\treceiver: object\n\t): boolean {\n\t\tif ( readOnlyProxies.has( receiver ) ) {\n\t\t\treturn false;\n\t\t}\n\t\tsetNamespace( getNamespaceFromProxy( receiver ) );\n\t\ttry {\n\t\t\treturn Reflect.set( target, key, value, receiver );\n\t\t} finally {\n\t\t\tresetNamespace();\n\t\t}\n\t},\n\n\tdefineProperty(\n\t\ttarget: object,\n\t\tkey: string,\n\t\tdesc: PropertyDescriptor\n\t): boolean {\n\t\tif ( readOnlyProxies.has( getProxyFromObject( target )! ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst isNew = ! ( key in target );\n\t\tconst result = Reflect.defineProperty( target, key, desc );\n\n\t\tif ( result ) {\n\t\t\tconst receiver = getProxyFromObject( target )!;\n\t\t\tconst prop = getPropSignal( receiver, key );\n\t\t\tconst { get, value } = desc;\n\t\t\tif ( get ) {\n\t\t\t\tprop.setGetter( get );\n\t\t\t} else {\n\t\t\t\tconst ns = getNamespaceFromProxy( receiver );\n\t\t\t\tprop.setValue(\n\t\t\t\t\tshouldProxy( value ) ? proxifyState( ns, value ) : value\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif ( isNew && objToIterable.has( target ) ) {\n\t\t\t\tobjToIterable.get( target )!.value++;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Modify the `length` property value only if the related\n\t\t\t * `PropSignal` exists, which means that there are subscriptions to\n\t\t\t * this property.\n\t\t\t */\n\t\t\tif (\n\t\t\t\tArray.isArray( target ) &&\n\t\t\t\tproxyToProps.get( receiver )?.has( 'length' )\n\t\t\t) {\n\t\t\t\tconst length = getPropSignal( receiver, 'length' );\n\t\t\t\tlength.setValue( target.length );\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t},\n\n\tdeleteProperty( target: object, key: string ): boolean {\n\t\tif ( readOnlyProxies.has( getProxyFromObject( target )! ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst result = Reflect.deleteProperty( target, key );\n\n\t\tif ( result ) {\n\t\t\tconst prop = getPropSignal( getProxyFromObject( target )!, key );\n\t\t\tprop.setValue( undefined );\n\n\t\t\tif ( objToIterable.has( target ) ) {\n\t\t\t\tobjToIterable.get( target )!.value++;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t},\n\n\townKeys( target: object ): ( string | symbol )[] {\n\t\tif ( ! objToIterable.has( target ) ) {\n\t\t\tobjToIterable.set( target, signal( 0 ) );\n\t\t}\n\t\t/*\n\t\t *This subscribes to the signal while preventing the minifier from\n\t\t * deleting this line in production.\n\t\t */\n\t\t( objToIterable as any )._ = objToIterable.get( target )!.value;\n\t\treturn Reflect.ownKeys( target );\n\t},\n};\n\n/**\n * Returns the proxy associated with the given state object, creating it if it\n * does not exist.\n *\n * @param namespace        The namespace that will be associated to this proxy.\n * @param obj              The object to proxify.\n * @param options          Options.\n * @param options.readOnly Read-only.\n *\n * @throws Error if the object cannot be proxified. Use {@link shouldProxy} to\n *         check if a proxy can be created for a specific object.\n *\n * @return The associated proxy.\n */\nexport const proxifyState = < T extends object >(\n\tnamespace: string,\n\tobj: T,\n\toptions?: { readOnly?: boolean }\n): T => {\n\tconst proxy = createProxy( namespace, obj, stateHandlers ) as T;\n\tif ( options?.readOnly ) {\n\t\treadOnlyProxies.add( proxy );\n\t}\n\treturn proxy;\n};\n\n/**\n * Reads the value of the specified property without subscribing to it.\n *\n * @param obj The object to read the property from.\n * @param key The property key.\n * @return The property value.\n */\nexport const peek = < T extends object, K extends keyof T >(\n\tobj: T,\n\tkey: K\n): T[ K ] => {\n\tpeeking = true;\n\ttry {\n\t\treturn obj[ key ];\n\t} finally {\n\t\tpeeking = false;\n\t}\n};\n\n/**\n * Internal recursive implementation for {@link deepMerge | `deepMerge`}.\n *\n * @param target   The target object.\n * @param source   The source object containing new values and props.\n * @param override Whether existing props should be overwritten or not (`true`\n *                 by default).\n */\nconst deepMergeRecursive = (\n\ttarget: any,\n\tsource: any,\n\toverride: boolean = true\n) => {\n\t// If target is not a plain object and the source is, we don't need to merge\n\t// them because the source will be used as the new value of the target.\n\tif ( ! ( isPlainObject( target ) && isPlainObject( source ) ) ) {\n\t\treturn;\n\t}\n\n\tlet hasNewKeys = false;\n\n\tfor ( const key in source ) {\n\t\tconst isNew = ! ( key in target );\n\t\thasNewKeys = hasNewKeys || isNew;\n\n\t\tconst desc = Object.getOwnPropertyDescriptor( source, key )!;\n\t\tconst proxy = getProxyFromObject( target );\n\t\tconst propSignal =\n\t\t\t!! proxy &&\n\t\t\thasPropSignal( proxy, key ) &&\n\t\t\tgetPropSignal( proxy, key );\n\n\t\t// Handle getters and setters\n\t\tif (\n\t\t\ttypeof desc.get === 'function' ||\n\t\t\ttypeof desc.set === 'function'\n\t\t) {\n\t\t\tif ( override || isNew ) {\n\t\t\t\t// Because we are setting a getter or setter, we need to use\n\t\t\t\t// Object.defineProperty to define the property on the target object.\n\t\t\t\tObject.defineProperty( target, key, {\n\t\t\t\t\t...desc,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t} );\n\t\t\t\t// Update the getter in the property signal if it exists\n\t\t\t\tif ( desc.get && propSignal ) {\n\t\t\t\t\tpropSignal.setGetter( desc.get );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Handle nested objects\n\t\t} else if ( isPlainObject( source[ key ] ) ) {\n\t\t\tconst targetValue = Object.getOwnPropertyDescriptor( target, key )\n\t\t\t\t?.value;\n\t\t\tif ( isNew || ( override && ! isPlainObject( targetValue ) ) ) {\n\t\t\t\t// Create a new object if the property is new or needs to be overridden\n\t\t\t\ttarget[ key ] = {};\n\t\t\t\tif ( propSignal ) {\n\t\t\t\t\t// Create a new proxified state for the nested object\n\t\t\t\t\tconst ns = getNamespaceFromProxy( proxy );\n\t\t\t\t\tpropSignal.setValue(\n\t\t\t\t\t\tproxifyState( ns, target[ key ] as Object )\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tdeepMergeRecursive( target[ key ], source[ key ], override );\n\t\t\t}\n\t\t\t// Both target and source are plain objects, merge them recursively\n\t\t\telse if ( isPlainObject( targetValue ) ) {\n\t\t\t\tdeepMergeRecursive( target[ key ], source[ key ], override );\n\t\t\t}\n\n\t\t\t// Handle primitive values and non-plain objects\n\t\t} else if ( override || isNew ) {\n\t\t\tObject.defineProperty( target, key, desc );\n\t\t\tif ( propSignal ) {\n\t\t\t\tconst { value } = desc;\n\t\t\t\tconst ns = getNamespaceFromProxy( proxy );\n\t\t\t\t// Proxify the value if necessary before setting it in the signal\n\t\t\t\tpropSignal.setValue(\n\t\t\t\t\tshouldProxy( value ) ? proxifyState( ns, value ) : value\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( hasNewKeys && objToIterable.has( target ) ) {\n\t\tobjToIterable.get( target )!.value++;\n\t}\n};\n\n/**\n * Recursively update prop values inside the passed `target` and nested plain\n * objects, using the values present in `source`. References to plain objects\n * are kept, only updating props containing primitives or arrays. Arrays are\n * replaced instead of merged or concatenated.\n *\n * If the `override` parameter is set to `false`, then all values in `target`\n * are preserved, and only new properties from `source` are added.\n *\n * @param target   The target object.\n * @param source   The source object containing new values and props.\n * @param override Whether existing props should be overwritten or not (`true`\n *                 by default).\n */\nexport const deepMerge = (\n\ttarget: any,\n\tsource: any,\n\toverride: boolean = true\n) =>\n\tbatch( () =>\n\t\tdeepMergeRecursive(\n\t\t\tgetObjectFromProxy( target ) || target,\n\t\t\tsource,\n\t\t\toverride\n\t\t)\n\t);\n"],"mappings":"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","ignoreList":[]}