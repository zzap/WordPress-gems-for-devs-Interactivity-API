const contextObjectToProxy = /* @__PURE__ */ new WeakMap();
const contextObjectToFallback = /* @__PURE__ */ new WeakMap();
const contextProxies = /* @__PURE__ */ new WeakSet();
const descriptor = Reflect.getOwnPropertyDescriptor;
const contextHandlers = {
  get: (target, key) => {
    const fallback = contextObjectToFallback.get(target);
    const currentProp = target[key];
    return key in target ? currentProp : fallback[key];
  },
  set: (target, key, value) => {
    const fallback = contextObjectToFallback.get(target);
    const obj = key in target || !(key in fallback) ? target : fallback;
    obj[key] = value;
    return true;
  },
  ownKeys: (target) => [
    .../* @__PURE__ */ new Set([
      ...Object.keys(contextObjectToFallback.get(target)),
      ...Object.keys(target)
    ])
  ],
  getOwnPropertyDescriptor: (target, key) => descriptor(target, key) || descriptor(contextObjectToFallback.get(target), key),
  has: (target, key) => Reflect.has(target, key) || Reflect.has(contextObjectToFallback.get(target), key)
};
const proxifyContext = (current, inherited = {}) => {
  if (contextProxies.has(current)) {
    throw Error("This object cannot be proxified.");
  }
  contextObjectToFallback.set(current, inherited);
  if (!contextObjectToProxy.has(current)) {
    const proxy = new Proxy(current, contextHandlers);
    contextObjectToProxy.set(current, proxy);
    contextProxies.add(proxy);
  }
  return contextObjectToProxy.get(current);
};
export {
  proxifyContext
};
//# sourceMappingURL=context.js.map
