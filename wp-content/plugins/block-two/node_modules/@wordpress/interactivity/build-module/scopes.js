import { getNamespace } from "./namespaces";
import { deepReadOnly, navigationSignal } from "./utils";
const scopeStack = [];
const getScope = () => scopeStack.slice(-1)[0];
const setScope = (scope) => {
  scopeStack.push(scope);
};
const resetScope = () => {
  scopeStack.pop();
};
const throwNotInScope = (method) => {
  throw Error(
    `Cannot call \`${method}()\` when there is no scope. If you are using an async function, please consider using a generator instead. If you are using some sort of async callbacks, like \`setTimeout\`, please wrap the callback with \`withScope(callback)\`.`
  );
};
const getContext = (namespace) => {
  const scope = getScope();
  if (globalThis.SCRIPT_DEBUG) {
    if (!scope) {
      throwNotInScope("getContext");
    }
  }
  return scope.context[namespace || getNamespace()];
};
const getElement = () => {
  const scope = getScope();
  let deepReadOnlyOptions = {};
  if (globalThis.SCRIPT_DEBUG) {
    if (!scope) {
      throwNotInScope("getElement");
    }
    deepReadOnlyOptions = {
      errorMessage: "Don't mutate the attributes from `getElement`, use `data-wp-bind` to modify the attributes of an element instead."
    };
  }
  const { ref, attributes } = scope;
  return Object.freeze({
    ref: ref.current,
    attributes: deepReadOnly(attributes, deepReadOnlyOptions)
  });
};
function getServerContext(namespace) {
  const scope = getScope();
  if (globalThis.SCRIPT_DEBUG) {
    if (!scope) {
      throwNotInScope("getServerContext");
    }
  }
  getServerContext.subscribe = navigationSignal.value;
  return scope.serverContext[namespace || getNamespace()];
}
getServerContext.subscribe = 0;
export {
  getContext,
  getElement,
  getScope,
  getServerContext,
  resetScope,
  setScope
};
//# sourceMappingURL=scopes.js.map
