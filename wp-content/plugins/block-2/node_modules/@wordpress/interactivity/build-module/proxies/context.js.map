{
  "version": 3,
  "sources": ["../../src/proxies/context.ts"],
  "sourcesContent": ["const contextObjectToProxy = new WeakMap();\nconst contextObjectToFallback = new WeakMap();\nconst contextProxies = new WeakSet();\n\nconst descriptor = Reflect.getOwnPropertyDescriptor;\n\n// TODO: Use the proxy registry to avoid multiple proxies on the same object.\nconst contextHandlers: ProxyHandler< object > = {\n\tget: ( target, key ) => {\n\t\tconst fallback = contextObjectToFallback.get( target );\n\t\t// Always subscribe to prop changes in the current context.\n\t\tconst currentProp = target[ key ];\n\n\t\t/*\n\t\t * Return the value from `target` if it exists, or from `fallback`\n\t\t * otherwise. This way, in the case the property doesn't exist either in\n\t\t * `target` or `fallback`, it also subscribes to changes in the parent\n\t\t * context.\n\t\t */\n\t\treturn key in target ? currentProp : fallback[ key ];\n\t},\n\tset: ( target, key, value ) => {\n\t\tconst fallback = contextObjectToFallback.get( target );\n\n\t\t// If the property exists in the current context, modify it. Otherwise,\n\t\t// add it to the current context.\n\t\tconst obj = key in target || ! ( key in fallback ) ? target : fallback;\n\t\tobj[ key ] = value;\n\n\t\treturn true;\n\t},\n\townKeys: ( target ) => [\n\t\t...new Set( [\n\t\t\t...Object.keys( contextObjectToFallback.get( target ) ),\n\t\t\t...Object.keys( target ),\n\t\t] ),\n\t],\n\tgetOwnPropertyDescriptor: ( target, key ) =>\n\t\tdescriptor( target, key ) ||\n\t\tdescriptor( contextObjectToFallback.get( target ), key ),\n\thas: ( target, key ) =>\n\t\tReflect.has( target, key ) ||\n\t\tReflect.has( contextObjectToFallback.get( target ), key ),\n};\n\n/**\n * Wraps a context object with a proxy to reproduce the context stack. The proxy\n * uses the passed `inherited` context as a fallback to look up for properties\n * that don't exist in the given context. Also, updated properties are modified\n * where they are defined, or added to the main context when they don't exist.\n *\n * @param current   Current context.\n * @param inherited Inherited context, used as fallback.\n *\n * @return The wrapped context object.\n */\nexport const proxifyContext = (\n\tcurrent: object,\n\tinherited: object = {}\n): object => {\n\tif ( contextProxies.has( current ) ) {\n\t\tthrow Error( 'This object cannot be proxified.' );\n\t}\n\t// Update the fallback object reference when it changes.\n\tcontextObjectToFallback.set( current, inherited );\n\tif ( ! contextObjectToProxy.has( current ) ) {\n\t\tconst proxy = new Proxy( current, contextHandlers );\n\t\tcontextObjectToProxy.set( current, proxy );\n\t\tcontextProxies.add( proxy );\n\t}\n\treturn contextObjectToProxy.get( current );\n};\n"],
  "mappings": ";AAAA,IAAM,uBAAuB,oBAAI,QAAQ;AACzC,IAAM,0BAA0B,oBAAI,QAAQ;AAC5C,IAAM,iBAAiB,oBAAI,QAAQ;AAEnC,IAAM,aAAa,QAAQ;AAG3B,IAAM,kBAA0C;AAAA,EAC/C,KAAK,CAAE,QAAQ,QAAS;AACvB,UAAM,WAAW,wBAAwB,IAAK,MAAO;AAErD,UAAM,cAAc,OAAQ,GAAI;AAQhC,WAAO,OAAO,SAAS,cAAc,SAAU,GAAI;AAAA,EACpD;AAAA,EACA,KAAK,CAAE,QAAQ,KAAK,UAAW;AAC9B,UAAM,WAAW,wBAAwB,IAAK,MAAO;AAIrD,UAAM,MAAM,OAAO,UAAU,EAAI,OAAO,YAAa,SAAS;AAC9D,QAAK,GAAI,IAAI;AAEb,WAAO;AAAA,EACR;AAAA,EACA,SAAS,CAAE,WAAY;AAAA,IACtB,GAAG,oBAAI,IAAK;AAAA,MACX,GAAG,OAAO,KAAM,wBAAwB,IAAK,MAAO,CAAE;AAAA,MACtD,GAAG,OAAO,KAAM,MAAO;AAAA,IACxB,CAAE;AAAA,EACH;AAAA,EACA,0BAA0B,CAAE,QAAQ,QACnC,WAAY,QAAQ,GAAI,KACxB,WAAY,wBAAwB,IAAK,MAAO,GAAG,GAAI;AAAA,EACxD,KAAK,CAAE,QAAQ,QACd,QAAQ,IAAK,QAAQ,GAAI,KACzB,QAAQ,IAAK,wBAAwB,IAAK,MAAO,GAAG,GAAI;AAC1D;AAaO,IAAM,iBAAiB,CAC7B,SACA,YAAoB,CAAC,MACT;AACZ,MAAK,eAAe,IAAK,OAAQ,GAAI;AACpC,UAAM,MAAO,kCAAmC;AAAA,EACjD;AAEA,0BAAwB,IAAK,SAAS,SAAU;AAChD,MAAK,CAAE,qBAAqB,IAAK,OAAQ,GAAI;AAC5C,UAAM,QAAQ,IAAI,MAAO,SAAS,eAAgB;AAClD,yBAAqB,IAAK,SAAS,KAAM;AACzC,mBAAe,IAAK,KAAM;AAAA,EAC3B;AACA,SAAO,qBAAqB,IAAK,OAAQ;AAC1C;",
  "names": []
}
