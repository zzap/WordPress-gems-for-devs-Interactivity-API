{
  "version": 3,
  "sources": ["../../src/proxies/store.ts"],
  "sourcesContent": ["/**\n * Internal dependencies\n */\nimport { createProxy, getNamespaceFromProxy, shouldProxy } from './registry';\n/**\n * External dependencies\n */\nimport { setNamespace, resetNamespace } from '../namespaces';\nimport { withScope, isPlainObject } from '../utils';\n\n/**\n * Identifies the store proxies handling the root objects of each store.\n */\nconst storeRoots = new WeakSet();\n\n/**\n * Handlers for store proxies.\n */\nconst storeHandlers: ProxyHandler< object > = {\n\tget: ( target: any, key: string | symbol, receiver: any ) => {\n\t\tconst result = Reflect.get( target, key );\n\t\tconst ns = getNamespaceFromProxy( receiver );\n\n\t\t/*\n\t\t * Check if the proxy is the store root and no key with that name exist. In\n\t\t * that case, return an empty object for the requested key.\n\t\t */\n\t\tif ( typeof result === 'undefined' && storeRoots.has( receiver ) ) {\n\t\t\tconst obj = {};\n\t\t\tReflect.set( target, key, obj );\n\t\t\treturn proxifyStore( ns, obj, false );\n\t\t}\n\n\t\t/*\n\t\t * Check if the property is a function. If it is, add the store\n\t\t * namespace to the stack and wrap the function with the current scope.\n\t\t * The `withScope` util handles both synchronous functions and generator\n\t\t * functions.\n\t\t */\n\t\tif ( typeof result === 'function' ) {\n\t\t\tsetNamespace( ns );\n\t\t\tconst scoped = withScope( result );\n\t\t\tresetNamespace();\n\t\t\treturn scoped;\n\t\t}\n\n\t\t// Check if the property is an object. If it is, proxyify it.\n\t\tif ( isPlainObject( result ) && shouldProxy( result ) ) {\n\t\t\treturn proxifyStore( ns, result, false );\n\t\t}\n\n\t\treturn result;\n\t},\n};\n\n/**\n * Returns the proxy associated with the given store object, creating it if it\n * does not exist.\n *\n * @param namespace The namespace that will be associated to this proxy.\n * @param obj       The object to proxify.\n *\n * @param isRoot    Whether the passed object is the store root object.\n * @throws Error if the object cannot be proxified. Use {@link shouldProxy} to\n *         check if a proxy can be created for a specific object.\n *\n * @return The associated proxy.\n */\nexport const proxifyStore = < T extends object >(\n\tnamespace: string,\n\tobj: T,\n\tisRoot = true\n): T => {\n\tconst proxy = createProxy( namespace, obj, storeHandlers );\n\tif ( proxy && isRoot ) {\n\t\tstoreRoots.add( proxy );\n\t}\n\treturn proxy as T;\n};\n"],
  "mappings": ";AAGA,SAAS,aAAa,uBAAuB,mBAAmB;AAIhE,SAAS,cAAc,sBAAsB;AAC7C,SAAS,WAAW,qBAAqB;AAKzC,IAAM,aAAa,oBAAI,QAAQ;AAK/B,IAAM,gBAAwC;AAAA,EAC7C,KAAK,CAAE,QAAa,KAAsB,aAAmB;AAC5D,UAAM,SAAS,QAAQ,IAAK,QAAQ,GAAI;AACxC,UAAM,KAAK,sBAAuB,QAAS;AAM3C,QAAK,OAAO,WAAW,eAAe,WAAW,IAAK,QAAS,GAAI;AAClE,YAAM,MAAM,CAAC;AACb,cAAQ,IAAK,QAAQ,KAAK,GAAI;AAC9B,aAAO,aAAc,IAAI,KAAK,KAAM;AAAA,IACrC;AAQA,QAAK,OAAO,WAAW,YAAa;AACnC,mBAAc,EAAG;AACjB,YAAM,SAAS,UAAW,MAAO;AACjC,qBAAe;AACf,aAAO;AAAA,IACR;AAGA,QAAK,cAAe,MAAO,KAAK,YAAa,MAAO,GAAI;AACvD,aAAO,aAAc,IAAI,QAAQ,KAAM;AAAA,IACxC;AAEA,WAAO;AAAA,EACR;AACD;AAeO,IAAM,eAAe,CAC3B,WACA,KACA,SAAS,SACF;AACP,QAAM,QAAQ,YAAa,WAAW,KAAK,aAAc;AACzD,MAAK,SAAS,QAAS;AACtB,eAAW,IAAK,KAAM;AAAA,EACvB;AACA,SAAO;AACR;",
  "names": []
}
